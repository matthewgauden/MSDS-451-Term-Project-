# -*- coding: utf-8 -*-
"""MSDS_451_Final_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KIEwvFsuow0RxIk83TGLqSaR9u-bLa2A

# Final Project - Matt Gauden
# Multiple ETF Management Fund

## Import Libraries
"""

import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import warnings
# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

"""## Retrieve Data"""

# Specify the time period
start_date = '2005-01-01'
end_date = '2025-01-01'

startfile = "assignment_3"

# Use yfinance to retrieve data
symbols = ['SPY', 'TLT', 'VTI']

historical_data = {}

for symbol in symbols:
    ticker = yf.Ticker(symbol)
    data = ticker.history(start='2005-01-01', end='2025-01-01')
    historical_data[symbol] = data
    # Save data to CSV
    data.to_csv(f"{startfile}_{symbol.lower()}.csv")

"""## Prepare Data"""

# Combine the data into one df
combined_data = pd.concat(historical_data.values(), keys=historical_data.keys(), axis=1)

#print(combined_data.head())

# Calculate log daily returns
close_df = combined_data.xs('Close', level=1, axis=1)

log_daily_returns = np.log(close_df / close_df.shift(1))

print(log_daily_returns.head())

"""## Implement Clenow Momentum Strategy"""

# Calculate the 20-day rolling standard deviation for each asset
rolling_volatility = log_daily_returns.rolling(window=20).std()

# Drop rows with NaN values
rolling_volatility = rolling_volatility.dropna()

# Calculate the inverse of the rolling volatility
inverse_volatility = 1 / rolling_volatility.replace([np.inf, -np.inf], np.nan).fillna(0)

# Calculate the sum of inverse volatilities for normalization
sum_inverse_volatility = inverse_volatility.sum(axis=1)

# Normalize the inverse volatilities to get weights that sum to 1
inverse_volatility_weights = inverse_volatility.divide(sum_inverse_volatility, axis=0).fillna(0)

# Store the calculated weights
log_daily_returns_aligned = log_daily_returns.loc[inverse_volatility_weights.index]

for symbol in symbols:
    log_daily_returns_aligned[f'{symbol}_inverse_volatility_weight'] = inverse_volatility_weights[symbol]

#print(log_daily_returns_aligned.head())

"""## Calculate Momentum"""

# Calculate momentum (125-day slope of log returns)
momentum_window = 125

# Calculate the rolling slope of the cumulative log returns for each asset
def calculate_rolling_slope(series, window):
    # Calculate cumulative sum of log returns over the rolling window
    rolling_cumulative_returns = series.rolling(window=window).sum()

    # Function to calculate the slope for a given window of data
    def get_slope(data):
        if len(data) < window or np.isnan(data).any():
            return np.nan
        x = np.arange(len(data))
        return np.polyfit(x, data, 1)[0]

    # Apply the get_slope function to the rolling window
    # Use axis=0 to apply the function to each column (asset) over the rolling window (rows)
    return rolling_cumulative_returns.rolling(window=window).apply(get_slope, raw=True)

# Apply the calculate_rolling_slope function to each asset's log daily returns
momentum_slope = log_daily_returns_aligned[symbols].apply(calculate_rolling_slope, axis=0, window=momentum_window)

# Drop rows with NaN values
momentum_slope = momentum_slope.dropna()

print(momentum_slope.head())

"""## Calculate Trend Filter"""

# Calculate the 200-day moving average of the S&P 500 (SPY) closing price
spy_close = close_df['SPY']
spy_moving_average_200 = spy_close.rolling(window=200).mean()

# Determine the trend filter: positive if SPY close is above its 200-day moving average
trend_filter = spy_close > spy_moving_average_200

# Align the trend filter with the returns data
trend_filter = trend_filter.loc[log_daily_returns_aligned.index]

print(trend_filter.head())

"""## Generate Trading Signals"""

# Define the minimum required momentum value
min_momentum = 0.0005

# Align trend_filter with momentum_slope index
trend_filter_aligned = trend_filter.loc[momentum_slope.index]

# Generate trading signals based on trend filter and momentum
trading_signals = pd.DataFrame(index=momentum_slope.index)

for symbol in symbols:
    asset_momentum = momentum_slope[symbol]
    # Signal is True if trend filter is positive AND momentum is above the minimum
    trading_signals[symbol] = (trend_filter_aligned) & (asset_momentum > min_momentum)

print(trading_signals.head())

# Apply trading signals to inverse volatility weights
# If signal is True, use the inverse volatility weight; otherwise, the weight is 0 (cash)
portfolio_weights = inverse_volatility_weights.loc[trading_signals.index] * trading_signals

# Normalize weights across selected assets for each day to sum to 1
row_sums = portfolio_weights.sum(axis=1)
portfolio_weights = portfolio_weights.divide(row_sums, axis=0).fillna(0)

print(portfolio_weights.head())

"""## Backtest Strategy"""

# Calculate portfolio daily returns
portfolio_daily_returns = (portfolio_weights * log_daily_returns_aligned[symbols]).sum(axis=1)

# Calculate cumulative portfolio returns
cumulative_portfolio_returns = np.exp(portfolio_daily_returns.cumsum())

print(cumulative_portfolio_returns.head())

"""## Implement Monthly Rebalancing"""

# Resample weights to monthly frequency and forward fill to maintain weights throughout the month
monthly_portfolio_weights = portfolio_weights.resample('M').first()
monthly_portfolio_weights = monthly_portfolio_weights.reindex(portfolio_weights.index, method='ffill')

# Ensure weights are still normalized to 1 each day after rebalancing
row_sums_monthly = monthly_portfolio_weights.sum(axis=1)
monthly_portfolio_weights = monthly_portfolio_weights.divide(row_sums_monthly, axis=0).fillna(0)

# Replace the daily portfolio_weights with the monthly rebalanced weights
portfolio_weights = monthly_portfolio_weights

print(portfolio_weights.head())

"""## Evaluate Performance"""

# Total Return
total_return = cumulative_portfolio_returns.iloc[-1] - 1

# Annualized Return (assuming daily data and 252 trading days in a year)
# Calculate the number of years
years = (cumulative_portfolio_returns.index[-1] - cumulative_portfolio_returns.index[0]).days / 365.25
annualized_return = (1 + total_return)**(1/years) - 1

# Annualized Volatility
annualized_volatility = portfolio_daily_returns.std() * np.sqrt(252)

# Sharpe Ratio (assuming risk-free rate is 0 for simplicity)
sharpe_ratio = annualized_return / annualized_volatility

# Maximum Drawdown
# Calculate the running maximum
running_max = cumulative_portfolio_returns.cummax()
# Calculate the drawdown
drawdown = running_max - cumulative_portfolio_returns
# Calculate the maximum drawdown
max_drawdown = drawdown.max() / running_max.max()


print(f"Total Return: {total_return:.4f}")
print(f"Annualized Return: {annualized_return:.4f}")
print(f"Annualized Volatility: {annualized_volatility:.4f}")
print(f"Sharpe Ratio: {sharpe_ratio:.4f}")
print(f"Maximum Drawdown: {max_drawdown:.4f}")

# Plot cumulative returns
plt.figure(figsize=(12, 6))
plt.plot(cumulative_portfolio_returns)
plt.title('Cumulative Portfolio Returns')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.grid(True)
plt.show()

"""# Baseline

Above we've gathered the baseline for the fund's performance implementing Clenow's momentum strategy

## Original Strategy Stats
"""

print("\n--- Current Performance Metrics (Baseline) ---")
print(f"Total Return: {total_return:.4f}")
print(f"Annualized Return: {annualized_return:.4f}")
print(f"Annualized Volatility: {annualized_volatility:.4f}")
print(f"Sharpe Ratio: {sharpe_ratio:.4f}")
print(f"Maximum Drawdown: {max_drawdown:.4f}")

"""## Use SPX as a Comparison Metric"""

spx_data = yf.Ticker('^GSPC').history(start=start_date, end=end_date)

##display(spx_data.head())

spx_returns = np.log(spx_data['Close'] / spx_data['Close'].shift(1))
spx_returns = spx_returns.dropna()
display(spx_returns.head())

"""## Compare Sharpe Ratios"""

# Calculate Annualized Volatility for SPX
spx_annualized_volatility = spx_returns.std() * np.sqrt(252)

# Calculate Annualized Return for SPX
# Align SPX returns with the portfolio's cumulative returns index for a comparable time frame
spx_returns_aligned = spx_returns.loc[cumulative_portfolio_returns.index]
spx_total_return_aligned = np.exp(spx_returns_aligned.sum()) - 1
spx_years_aligned = (spx_returns_aligned.index[-1] - spx_returns_aligned.index[0]).days / 365.25
spx_annualized_return = (1 + spx_total_return_aligned)**(1/spx_years_aligned) - 1

# Calculate Sharpe Ratio for SPX
spx_sharpe_ratio = spx_annualized_return / spx_annualized_volatility

print(f"Portfolio Sharpe Ratio: {sharpe_ratio:.4f}")
print(f"SPX Sharpe Ratio: {spx_sharpe_ratio:.4f}")

# Calculate Maximum Drawdown for SPX
# Calculate the running maximum for SPX cumulative returns
spx_running_max = cumulative_spx_returns.cummax()
# Calculate the drawdown for SPX
spx_drawdown = spx_running_max - cumulative_spx_returns
# Calculate the maximum drawdown for QQQ
spx_max_drawdown = spx_drawdown.max() / spx_running_max.max()

print(f"Portfolio Maximum Drawdown: {max_drawdown:.4f}")
print(f"SPX Maximum Drawdown: {spx_max_drawdown:.4f}")

"""## Compare to SPX Benchmark"""

# Calculate cumulative QQQ returns
cumulative_spx_returns = np.exp(spx_returns.cumsum())

# Align the cumulative returns dataframes by index
aligned_cumulative_returns = pd.concat([cumulative_portfolio_returns, cumulative_spx_returns], axis=1).dropna()
aligned_cumulative_returns.columns = ['Portfolio', '^GSPC']

# Plot cumulative returns for both the portfolio and QQQ
plt.figure(figsize=(12, 6))
plt.plot(aligned_cumulative_returns['Portfolio'], label='Portfolio')
plt.plot(aligned_cumulative_returns['^GSPC'], label='SPX')
plt.title('Cumulative Portfolio Returns vs. SPX Benchmark')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.legend()
plt.grid(True)
plt.show()

"""While our fund generated positive returns, there's still a large gap between the benchmark and the portfolio's performance.

A high-growth asset such as QQQ may need to be included in the fund.

## Add QQQ ETF
"""

symbols.append('QQQ')
min_momentum = 0.00001 # Altering min threshold to see if it increases returns

print(f"Updated symbols: {symbols}")
print(f"Updated minimum momentum threshold: {min_momentum}")

historical_data = {}

for symbol in symbols:
    ticker = yf.Ticker(symbol)
    data = ticker.history(start=start_date, end=end_date)
    historical_data[symbol] = data
    # Save data to CSV
    data.to_csv(f"{startfile}_{symbol.lower()}.csv")

combined_data = pd.concat(historical_data.values(), keys=historical_data.keys(), axis=1)

close_df = combined_data.xs('Close', level=1, axis=1)

log_daily_returns = np.log(close_df / close_df.shift(1))

print(log_daily_returns.head())

"""## Repeat Clenow's Momentum Strategy"""

# Calculate the 20-day rolling standard deviation for each asset
rolling_volatility = log_daily_returns.rolling(window=20).std()

# Drop rows with NaN values
rolling_volatility = rolling_volatility.dropna()

# Calculate the inverse of the rolling volatility
inverse_volatility = 1 / rolling_volatility.replace([np.inf, -np.inf], np.nan).fillna(0)

# Calculate the sum of inverse volatilities for normalization
sum_inverse_volatility = inverse_volatility.sum(axis=1)

# Normalize the inverse volatilities to get weights that sum to 1
inverse_volatility_weights = inverse_volatility.divide(sum_inverse_volatility, axis=0).fillna(0)

# Store the calculated weights
log_daily_returns_aligned = log_daily_returns.loc[inverse_volatility_weights.index]

for symbol in symbols:
    log_daily_returns_aligned[f'{symbol}_inverse_volatility_weight'] = inverse_volatility_weights[symbol]

#print(log_daily_returns_aligned.head())

# Calculate momentum (125-day slope of log returns)
momentum_window = 125

# Calculate the rolling slope of the cumulative log returns for each asset
def calculate_rolling_slope(series, window):
    # Calculate cumulative sum of log returns over the rolling window
    rolling_cumulative_returns = series.rolling(window=window).sum()

    # Function to calculate the slope for a given window of data
    def get_slope(data):
        if len(data) < window or np.isnan(data).any():
            return np.nan
        x = np.arange(len(data))
        return np.polyfit(x, data, 1)[0]

    # Apply the get_slope function to the rolling window
    # Use axis=0 to apply the function to each column (asset) over the rolling window (rows)
    return rolling_cumulative_returns.rolling(window=window).apply(get_slope, raw=True)

# Apply the calculate_rolling_slope function to each asset's log daily returns
momentum_slope = log_daily_returns_aligned[symbols].apply(calculate_rolling_slope, axis=0, window=momentum_window)

# Drop rows with NaN values
momentum_slope = momentum_slope.dropna()

print(momentum_slope.head())

# Calculate the 200-day moving average of the S&P 500 (SPY) closing price
spy_close = close_df['SPY']
spy_moving_average_200 = spy_close.rolling(window=200).mean()

# Determine the trend filter: positive if SPY close is above its 200-day moving average
trend_filter = spy_close > spy_moving_average_200

# Align the trend filter with the returns data
trend_filter = trend_filter.loc[log_daily_returns_aligned.index]

print(trend_filter.head())

"""## Generate Trading Signals"""

# Define the minimum required momentum value

# Align trend_filter with momentum_slope index
trend_filter_aligned = trend_filter.loc[momentum_slope.index]

# Generate trading signals based on trend filter and momentum
trading_signals = pd.DataFrame(index=momentum_slope.index)

for symbol in symbols:
    asset_momentum = momentum_slope[symbol]
    # Signal is True if trend filter is positive AND momentum is above the minimum
    trading_signals[symbol] = (trend_filter_aligned) & (asset_momentum > min_momentum)

print(trading_signals.head())

# Apply trading signals to inverse volatility weights
# If signal is True, use the inverse volatility weight; otherwise, the weight is 0 (cash)
portfolio_weights = inverse_volatility_weights.loc[trading_signals.index] * trading_signals

# Normalize weights across selected assets for each day to sum to 1
row_sums = portfolio_weights.sum(axis=1)
portfolio_weights = portfolio_weights.divide(row_sums, axis=0).fillna(0)

print(portfolio_weights.head())

"""## Calculate New Returns and Monthly Rebalancing"""

portfolio_daily_returns = (portfolio_weights * log_daily_returns_aligned[symbols]).sum(axis=1)
cumulative_portfolio_returns = np.exp(portfolio_daily_returns.cumsum())

print(cumulative_portfolio_returns.head())

monthly_portfolio_weights = portfolio_weights.resample('M').first()
monthly_portfolio_weights = monthly_portfolio_weights.reindex(portfolio_weights.index, method='ffill')

# Ensure weights are still normalized to 1 each day after rebalancing
row_sums_monthly = monthly_portfolio_weights.sum(axis=1)
monthly_portfolio_weights = monthly_portfolio_weights.divide(row_sums_monthly, axis=0).fillna(0)

# Replace the daily portfolio_weights with the monthly rebalanced weights
portfolio_weights = monthly_portfolio_weights

print(portfolio_weights.head())

"""## Plot Returns"""

portfolio_daily_returns = (portfolio_weights * log_daily_returns_aligned[symbols]).sum(axis=1)
cumulative_portfolio_returns = np.exp(portfolio_daily_returns.cumsum())

# Total Return
total_return = cumulative_portfolio_returns.iloc[-1] - 1

# Annualized Return (assuming daily data and 252 trading days in a year)
# Calculate the number of years
years = (cumulative_portfolio_returns.index[-1] - cumulative_portfolio_returns.index[0]).days / 365.25
annualized_return = (1 + total_return)**(1/years) - 1

# Annualized Volatility
annualized_volatility = portfolio_daily_returns.std() * np.sqrt(252)

# Sharpe Ratio (assuming risk-free rate is 0 for simplicity)
sharpe_ratio = annualized_return / annualized_volatility

# Maximum Drawdown
# Calculate the running maximum
running_max = cumulative_portfolio_returns.cummax()
# Calculate the drawdown
drawdown = running_max - cumulative_portfolio_returns
# Calculate the maximum drawdown
max_drawdown = drawdown.max() / running_max.max()


print(f"Total Return: {total_return:.4f}")
print(f"Annualized Return: {annualized_return:.4f}")
print(f"Annualized Volatility: {annualized_volatility:.4f}")
print(f"Sharpe Ratio: {sharpe_ratio:.4f}")
print(f"Maximum Drawdown: {max_drawdown:.4f}")

# Plot cumulative returns
plt.figure(figsize=(12, 6))
plt.plot(cumulative_portfolio_returns)
plt.title('Cumulative Portfolio Returns')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.grid(True)
plt.show()

"""## Measure New Portfolio Performance Against S&P 500"""

# Calculate Annualized Volatility for SPX (already calculated in previous step but ensured using the spx_returns dataframe)
spx_annualized_volatility = spx_returns.std() * np.sqrt(252)

# Align SPX returns with the portfolio's cumulative returns index for a comparable time frame
spx_returns_aligned_new = spx_returns.loc[cumulative_portfolio_returns.index]

# Calculate the total return for the aligned SPX data
spx_total_return_aligned_new = np.exp(spx_returns_aligned_new.sum()) - 1

# Calculate the number of years for the aligned SPX data
spx_years_aligned_new = (spx_returns_aligned_new.index[-1] - spx_returns_aligned_new.index[0]).days / 365.25

# Calculate the annualized return for the S&P 500 based on the aligned total return and years
spx_annualized_return_new = (1 + spx_total_return_aligned_new)**(1/spx_years_aligned_new) - 1

# Calculate Sharpe Ratio for SPX using its new annualized return and annualized volatility
spx_sharpe_ratio_new = spx_annualized_return_new / spx_annualized_volatility

print(f"Portfolio Sharpe Ratio: {sharpe_ratio:.4f}")
print(f"SPX Sharpe Ratio: {spx_sharpe_ratio_new:.4f}")

cumulative_spx_returns = np.exp(spx_returns_aligned_new.cumsum())

# Calculate Maximum Drawdown for SPX
# Calculate the running maximum for SPX cumulative returns
spx_running_max = cumulative_spx_returns.cummax()
# Calculate the drawdown for SPX
spx_drawdown = spx_running_max - cumulative_spx_returns
# Calculate the maximum drawdown for SPX
spx_max_drawdown = spx_drawdown.max() / spx_running_max.max()

print(f"Portfolio Maximum Drawdown: {max_drawdown:.4f}")
print(f"SPX Maximum Drawdown: {spx_max_drawdown:.4f}")

"""## Examine Alpha"""

print(f"Average Annual Returns for Baseline Portfolio: {0.0388:.4f}")
print(f"Average Annual Returns for Revised Portfolio: {annualized_return:.4f}")
print(f"Average Annual Returns for SPX: {spx_annualized_return_new:.4f}")

"""Average Annual Returns, or Alpha, will be important going forward as it will serve as the foundation for our hurdle-rate for the fund's fee structure.

## Monte Carlo Method
"""

print("First few rows of portfolio_daily_returns:")
print(portfolio_daily_returns.head())

print("\nNumber of missing values in portfolio_daily_returns:")
print(portfolio_daily_returns.isnull().sum())

mu = portfolio_daily_returns.mean()
sigma = portfolio_daily_returns.std()

print(f"Mean of daily returns (mu): {mu:.6f}")
print(f"Standard deviation of daily returns (sigma): {sigma:.6f}")

"""## Sim Parameters"""

num_simulations = 1000
num_trading_days = len(portfolio_daily_returns) # Use the length of historical data for simulation duration
initial_portfolio_value = 10000

print(f"Number of simulations: {num_simulations}")
print(f"Number of trading days to simulate: {num_trading_days}")
print(f"Initial portfolio value: {initial_portfolio_value}")

simulated_cumulative_returns = np.zeros((num_trading_days, num_simulations))

for i in range(num_simulations):
    # Generate random daily returns
    random_daily_returns = np.random.normal(mu, sigma, num_trading_days)

    # Calculate cumulative returns for this path
    # Initialize with initial_portfolio_value
    cumulative_path = initial_portfolio_value * np.exp(np.cumsum(random_daily_returns))
    simulated_cumulative_returns[:, i] = cumulative_path

print(f"Shape of simulated_cumulative_returns: {simulated_cumulative_returns.shape}")
print("First 5 rows of simulated_cumulative_returns (first 5 simulations):\n", simulated_cumulative_returns[:5, :5])

total_returns = np.zeros(num_simulations)
annualized_returns = np.zeros(num_simulations)
annualized_volatilities = np.zeros(num_simulations)
sharpe_ratios = np.zeros(num_simulations)
max_drawdowns = np.zeros(num_simulations)

for i in range(num_simulations):
    path = simulated_cumulative_returns[:, i]

    # Calculate Total Return
    total_returns[i] = path[-1] / path[0] - 1

    # Calculate Annualized Return
    years = num_trading_days / 252
    annualized_returns[i] = (1 + total_returns[i])**(1/years) - 1

    # Calculate Daily Returns for the path
    daily_returns = np.log(path[1:] / path[:-1])

    # Calculate Annualized Volatility
    annualized_volatilities[i] = daily_returns.std() * np.sqrt(252)

    # Calculate Sharpe Ratio (assume risk-free rate is 0)
    # Handle cases where annualized_volatility might be zero to avoid division by zero
    if annualized_volatilities[i] != 0:
        sharpe_ratios[i] = annualized_returns[i] / annualized_volatilities[i]
    else:
        sharpe_ratios[i] = 0 # Or np.nan, depending on desired handling of zero volatility

    # Calculate Maximum Drawdown
    running_max = np.maximum.accumulate(path)
    drawdown = (running_max - path) / running_max
    max_drawdowns[i] = drawdown.max()

print(f"Calculated metrics for {num_simulations} simulations:")
print(f"Average Total Return: {np.mean(total_returns):.4f}")
print(f"Average Annualized Return: {np.mean(annualized_returns):.4f}")
print(f"Average Annualized Volatility: {np.mean(annualized_volatilities):.4f}")
print(f"Average Sharpe Ratio: {np.mean(sharpe_ratios):.4f}")
print(f"Average Maximum Drawdown: {np.mean(max_drawdowns):.4f}")

"""The Monte Carlo simulation displays strong and similar results -- especially in regards to generating a similar Alpha to our portfolio -- given that these are the mean averages for each metric, we can be confident the fund will perform well.

## Plot Simulation
"""

#import matplotlib.pyplot as plt

# Plot a selection of simulated cumulative return paths
#plt.figure(figsize=(12, 7))
#plt.plot(simulated_cumulative_returns[:, :200], alpha=0.1, color='blue') # Plot first 200 paths for clarity
#plt.title('Monte Carlo Simulation: Cumulative Returns (Sampled Paths)')
#plt.xlabel('Trading Days')
#plt.ylabel('Cumulative Portfolio Value')
#plt.grid(True)
#plt.show()

#Create a figure with subplots to display histograms of the performance metrics
#fig, axes = plt.subplots(3, 1, figsize=(10, 15))

# Histogram for Total Returns
#axes[0].hist(total_returns, bins=50, color='skyblue', edgecolor='black')
#axes[0].set_title('Distribution of Total Returns (Monte Carlo)')
#axes[0].set_xlabel('Total Return')
#axes[0].set_ylabel('Frequency')
#axes[0].grid(True)

# Histogram for Sharpe Ratios
#axes[1].hist(sharpe_ratios, bins=50, color='lightgreen', edgecolor='black')
#axes[1].set_title('Distribution of Sharpe Ratios (Monte Carlo)')
#axes[1].set_xlabel('Sharpe Ratio')
#axes[1].set_ylabel('Frequency')
#axes[1].grid(True)

# Histogram for Maximum Drawdowns
#axes[2].hist(max_drawdowns, bins=50, color='lightcoral', edgecolor='black')
#axes[2].set_title('Distribution of Maximum Drawdowns (Monte Carlo)')
#axes[2].set_xlabel('Maximum Drawdown')
#axes[2].set_ylabel('Frequency')
#axes[2].grid(True)

# Use plt.tight_layout() to prevent labels from overlapping and plt.show() to display all generated plots
#plt.tight_layout()
#plt.show()

"""## Implementing Fees"""

annual_base_management_fee_percentage = 1.0 # 1% annual management fee
performance_fee_percentage = 5.0 # 5% performance fee
annual_hurdle_rate_percentage = 8.0 # 8% annual hurdle rate
initial_investment_fee_percentage = 1.0 # 1.0% initial investment fee

print(f"Annual Management Fee: {annual_base_management_fee_percentage}% ")
print(f"Performance Fee: {performance_fee_percentage}% ")
print(f"Annual Hurdle Rate: {annual_hurdle_rate_percentage}% ")
print(f"Initial Investment Fee: {initial_investment_fee_percentage}% ")

"""The 8% hurdle-rate is generated from our Alpha defined earlier.

If the portfolio exceeds this rate, then the client will be charged a higher amount in performance fees.
"""

trading_days_per_year = 252
daily_management_fee_rate = annual_base_management_fee_percentage / 100 / trading_days_per_year
initial_investment_fee_decimal = initial_investment_fee_percentage / 100

# Adjust initial portfolio value by deducting the initial investment fee
initial_portfolio_value_adjusted = initial_portfolio_value * (1 - initial_investment_fee_decimal)

# Calculate the daily portfolio returns after deducting the daily management fee rate
# The original portfolio_daily_returns are log returns. To subtract a percentage fee,
# we need to convert them to simple returns (exp(daily_return)), subtract the fee,
# and then convert back to log returns.
portfolio_daily_returns_with_fees = np.log(np.exp(portfolio_daily_returns) - daily_management_fee_rate)

print(f"Daily Management Fee Rate: {daily_management_fee_rate:.6f}")
print(f"Adjusted Initial Portfolio Value: {initial_portfolio_value_adjusted:.2f}")
print("First few rows of portfolio_daily_returns_with_fees:")
print(portfolio_daily_returns_with_fees.head())

"""## Fee Calculations"""

cumulative_portfolio_returns_with_fees = initial_portfolio_value_adjusted * np.exp(portfolio_daily_returns_with_fees.cumsum()) / initial_portfolio_value

# Total Return
total_return_with_fees = cumulative_portfolio_returns_with_fees.iloc[-1] - 1

# Annualized Return
years_with_fees = (cumulative_portfolio_returns_with_fees.index[-1] - cumulative_portfolio_returns_with_fees.index[0]).days / 365.25
annualized_return_with_fees = (1 + total_return_with_fees)**(1/years_with_fees) - 1

# Annualized Volatility
annualized_volatility_with_fees = portfolio_daily_returns_with_fees.std() * np.sqrt(trading_days_per_year)

# Sharpe Ratio
sharpe_ratio_with_fees = annualized_return_with_fees / annualized_volatility_with_fees

# Maximum Drawdown
running_max_with_fees = cumulative_portfolio_returns_with_fees.cummax()
drawdown_with_fees = running_max_with_fees - cumulative_portfolio_returns_with_fees
max_drawdown_with_fees = drawdown_with_fees.max() / running_max_with_fees.max()

daily_hurdle_rate = annual_hurdle_rate_percentage / 100 / trading_days_per_year

# This series will track the portfolio value after initial investment and management fees, but before performance fees.
temp_cumulative_value_before_pf_deduction = pd.Series(0.0, index=portfolio_daily_returns_with_fees.index)
temp_cumulative_value_before_pf_deduction.iloc[0] = initial_portfolio_value_adjusted

for i in range(1, len(portfolio_daily_returns_with_fees)):
    temp_cumulative_value_before_pf_deduction.iloc[i] = temp_cumulative_value_before_pf_deduction.iloc[i-1] * np.exp(portfolio_daily_returns_with_fees.iloc[i])

# Create an empty series to store the daily performance fees.
performance_fees_daily_amount = pd.Series(0.0, index=portfolio_daily_returns_with_fees.index)

# Loop to calculate performance fees
for i in range(1, len(temp_cumulative_value_before_pf_deduction)):
    prev_day_value = temp_cumulative_value_before_pf_deduction.iloc[i-1]
    current_day_value_before_pf = temp_cumulative_value_before_pf_deduction.iloc[i]

    # Calculate the daily simple return based on the current and previous day's cumulative value
    daily_simple_return_before_pf = (current_day_value_before_pf / prev_day_value) - 1

    # Determine if the daily_simple_return is greater than the daily_hurdle_rate
    if daily_simple_return_before_pf > daily_hurdle_rate:
        # Calculate the performance_fee_amount for that day
        excess_return = daily_simple_return_before_pf - daily_hurdle_rate
        performance_fees_daily_amount.iloc[i] = current_day_value_before_pf * (performance_fee_percentage / 100) * excess_return

# Calculate portfolio_daily_returns_with_adjusted_fees
# and cumulative_portfolio_returns_with_adjusted_fees (the final series after ALL fees)
final_cumulative_value = pd.Series(index=portfolio_daily_returns_with_fees.index)
portfolio_daily_returns_with_adjusted_fees = pd.Series(index=portfolio_daily_returns_with_fees.index)

final_cumulative_value.iloc[0] = initial_portfolio_value_adjusted
# For the very first day, only management fee applies (initial investment fee was already deducted from starting capital)
portfolio_daily_returns_with_adjusted_fees.iloc[0] = portfolio_daily_returns_with_fees.iloc[0]

for i in range(1, len(portfolio_daily_returns_with_fees)):
    prev_final_cumulative_value = final_cumulative_value.iloc[i-1]

    # Value for current day after management fees, but before performance fees
    value_after_mgmt_fees_for_current_day = temp_cumulative_value_before_pf_deduction.iloc[i]

    # Deduct performance fee amount to get the net value for the current day
    net_value_for_current_day = value_after_mgmt_fees_for_current_day - performance_fees_daily_amount.iloc[i]

    final_cumulative_value.iloc[i] = net_value_for_current_day

    # Calculate the daily net simple return after all fees
    daily_net_simple_return = (net_value_for_current_day / prev_final_cumulative_value) - 1

    # Convert to log return, handling potential non-positive values from extreme losses
    if 1 + daily_net_simple_return <= 0:
        portfolio_daily_returns_with_adjusted_fees.iloc[i] = np.nan # Or 0, or handle as error
    else:
        portfolio_daily_returns_with_adjusted_fees.iloc[i] = np.log(1 + daily_net_simple_return)

# Fill any NaN created by log transformation with 0
portfolio_daily_returns_with_adjusted_fees = portfolio_daily_returns_with_adjusted_fees.fillna(0)

# Calculate cumulative returns w/ fees
cumulative_portfolio_returns_with_adjusted_fees = final_cumulative_value / initial_portfolio_value

# Total Return
total_return_with_adjusted_fees = cumulative_portfolio_returns_with_adjusted_fees.iloc[-1] - 1

# Annualized Return
years_with_adjusted_fees = (cumulative_portfolio_returns_with_adjusted_fees.index[-1] - cumulative_portfolio_returns_with_adjusted_fees.index[0]).days / 365.25
annualized_return_with_adjusted_fees = (1 + total_return_with_adjusted_fees)**(1/years_with_adjusted_fees) - 1

# Annualized Volatility
annualized_volatility_with_adjusted_fees = portfolio_daily_returns_with_adjusted_fees.std() * np.sqrt(trading_days_per_year)

# Sharpe Ratio
sharpe_ratio_with_adjusted_fees = annualized_return_with_adjusted_fees / annualized_volatility_with_adjusted_fees

# Maximum Drawdown
running_max_with_adjusted_fees = cumulative_portfolio_returns_with_adjusted_fees.cummax()
drawdown_with_adjusted_fees = running_max_with_adjusted_fees - cumulative_portfolio_returns_with_adjusted_fees
max_drawdown_with_adjusted_fees = drawdown_with_adjusted_fees.max() / running_max_with_adjusted_fees.max()

print("\n--- Performance Metrics with Management and Performance Fees ---")
print(f"Total Return: {total_return_with_adjusted_fees:.4f}")
print(f"Annualized Return: {annualized_return_with_adjusted_fees:.4f}")
print(f"Annualized Volatility: {annualized_volatility_with_adjusted_fees:.4f}")
print(f"Sharpe Ratio: {sharpe_ratio_with_adjusted_fees:.4f}")
print(f"Maximum Drawdown: {max_drawdown_with_adjusted_fees:.4f}")

plt.figure(figsize=(14, 7))
plt.plot(cumulative_portfolio_returns, label='Portfolio (No Fees)', color='blue')
plt.plot(cumulative_portfolio_returns_with_adjusted_fees, label='Portfolio (Mgmt & Perf Fees)', color='green')
plt.plot(cumulative_spx_returns, label='SPX Benchmark', color='red', linestyle='--')

plt.title('Cumulative Portfolio Returns vs. SPX Benchmark with Fee Structures')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.legend()
plt.grid(True)
plt.show()

"""We've been able to establish a portfolio that displays strong results in terms of ROI, while still maintaining efficiency in regard to our Sharpe Ratio and Maximum Drawdown.

## Repeat Monte Carlo Simulation to Account for Fees
"""

print("First few rows of portfolio_daily_returns_with_adjusted_fees:")
print(portfolio_daily_returns_with_adjusted_fees.head())

print("\nNumber of missing values in portfolio_daily_returns_with_adjusted_fees:")
print(portfolio_daily_returns_with_adjusted_fees.isnull().sum())

mu_adjusted = portfolio_daily_returns_with_adjusted_fees.mean()
sigma_adjusted = portfolio_daily_returns_with_adjusted_fees.std()

print(f"Mean of daily returns with adjusted fees (mu_adjusted): {mu_adjusted:.6f}")
print(f"Standard deviation of daily returns with adjusted fees (sigma_adjusted): {sigma_adjusted:.6f}")

simulated_cumulative_returns_adjusted = np.zeros((num_trading_days, num_simulations))

for i in range(num_simulations):
    # Generate random daily returns using adjusted mu and sigma
    random_daily_returns_adjusted = np.random.normal(mu_adjusted, sigma_adjusted, num_trading_days)

    # Calculate cumulative returns for this path
    # Initialize with initial_portfolio_value_adjusted (after initial fee)
    cumulative_path_adjusted = initial_portfolio_value_adjusted * np.exp(np.cumsum(random_daily_returns_adjusted))
    simulated_cumulative_returns_adjusted[:, i] = cumulative_path_adjusted

print(f"Shape of simulated_cumulative_returns_adjusted: {simulated_cumulative_returns_adjusted.shape}")
print("First 5 rows of simulated_cumulative_returns_adjusted (first 5 simulations):\n", simulated_cumulative_returns_adjusted[:5, :5])

"""## Adjust Parameters"""

total_returns_adjusted = np.zeros(num_simulations)
annualized_returns_adjusted = np.zeros(num_simulations)
annualized_volatilities_adjusted = np.zeros(num_simulations)
sharpe_ratios_adjusted = np.zeros(num_simulations)
max_drawdowns_adjusted = np.zeros(num_simulations)

for i in range(num_simulations):
    path = simulated_cumulative_returns_adjusted[:, i]

    # Calculate Total Return
    total_returns_adjusted[i] = path[-1] / path[0] - 1

    # Calculate Annualized Return
    years = num_trading_days / trading_days_per_year # Use trading_days_per_year for consistency
    annualized_returns_adjusted[i] = (1 + total_returns_adjusted[i])**(1/years) - 1

    # Calculate Daily Returns for the path
    # Ensure path has enough elements before computing daily returns
    if len(path) > 1:
        daily_returns_path = np.log(path[1:] / path[:-1])
    else:
        daily_returns_path = np.array([0.0]) # Handle case of single-day path

    # Calculate Annualized Volatility
    annualized_volatilities_adjusted[i] = daily_returns_path.std() * np.sqrt(trading_days_per_year)

    # Calculate Sharpe Ratio (assume risk-free rate is 0)
    # Handle cases where annualized_volatility might be zero to avoid division by zero
    if annualized_volatilities_adjusted[i] != 0:
        sharpe_ratios_adjusted[i] = annualized_returns_adjusted[i] / annualized_volatilities_adjusted[i]
    else:
        sharpe_ratios_adjusted[i] = 0 # Or np.nan, depending on desired handling of zero volatility

    # Calculate Maximum Drawdown
    running_max = np.maximum.accumulate(path)
    # Handle division by zero if running_max starts at 0 or becomes 0
    if running_max.max() != 0:
        drawdown = (running_max - path) / running_max
        max_drawdowns_adjusted[i] = drawdown.max()
    else:
        max_drawdowns_adjusted[i] = 0

print(f"Calculated metrics for {num_simulations} simulations (with adjusted fees):")
print(f"Average Total Return: {np.mean(total_returns_adjusted):.4f}")
print(f"Average Annualized Return: {np.mean(annualized_returns_adjusted):.4f}")
print(f"Average Annualized Volatility: {np.mean(annualized_volatilities_adjusted):.4f}")
print(f"Average Sharpe Ratio: {np.mean(sharpe_ratios_adjusted):.4f}")
print(f"Average Maximum Drawdown: {np.mean(max_drawdowns_adjusted):.4f}")

import matplotlib.pyplot as plt

# Plot a selection of simulated cumulative return paths with adjusted fees
plt.figure(figsize=(12, 7))
plt.plot(simulated_cumulative_returns_adjusted[:, :200], alpha=0.1, color='purple') # Plot first 200 paths for clarity
plt.title('Monte Carlo Simulation (with Adjusted Fees): Cumulative Returns (Sampled Paths)')
plt.xlabel('Trading Days')
plt.ylabel('Cumulative Portfolio Value (with Adjusted Fees)')
plt.grid(True)
plt.show()

fig, axes = plt.subplots(3, 1, figsize=(10, 15))

# Histogram for Total Returns
axes[0].hist(total_returns_adjusted, bins=50, color='skyblue', edgecolor='black')
axes[0].set_title('Distribution of Total Returns (Monte Carlo with Adjusted Fees)')
axes[0].set_xlabel('Total Return')
axes[0].set_ylabel('Frequency')
axes[0].grid(True)

# Histogram for Sharpe Ratios
axes[1].hist(sharpe_ratios_adjusted, bins=50, color='lightgreen', edgecolor='black')
axes[1].set_title('Distribution of Sharpe Ratios (Monte Carlo with Adjusted Fees)')
axes[1].set_xlabel('Sharpe Ratio')
axes[1].set_ylabel('Frequency')
axes[1].grid(True)

# Histogram for Maximum Drawdowns
axes[2].hist(max_drawdowns_adjusted, bins=50, color='lightcoral', edgecolor='black')
axes[2].set_title('Distribution of Maximum Drawdowns (Monte Carlo with Adjusted Fees)')
axes[2].set_xlabel('Maximum Drawdown')
axes[2].set_ylabel('Frequency')
axes[2].grid(True)

plt.tight_layout()
plt.show()

print("--- Average Monte Carlo Metrics (No Fees) ---")
print(f"Average Total Return: {np.mean(total_returns):.4f}")
print(f"Average Annualized Return: {np.mean(annualized_returns):.4f}")
print(f"Average Annualized Volatility: {np.mean(annualized_volatilities):.4f}")
print(f"Average Sharpe Ratio: {np.mean(sharpe_ratios):.4f}")
print(f"Average Maximum Drawdown: {np.mean(max_drawdowns):.4f}")

print("\n--- Average Monte Carlo Metrics (With Adjusted Fees) ---")
print(f"Average Total Return: {np.mean(total_returns_adjusted):.4f}")
print(f"Average Annualized Return: {np.mean(annualized_returns_adjusted):.4f}")
print(f"Average Annualized Volatility: {np.mean(annualized_volatilities_adjusted):.4f}")
print(f"Average Sharpe Ratio: {np.mean(sharpe_ratios_adjusted):.4f}")
print(f"Average Maximum Drawdown: {np.mean(max_drawdowns_adjusted):.4f}")

!jupyter nbconvert --to html "/content/drive/MyDrive/Colab Notebooks/MSDS_451_Final_Project.ipynb"

!ls -l /content/